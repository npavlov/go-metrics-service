// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"

	domain "github.com/npavlov/go-metrics-service/internal/domain"
)

const GetAllMetrics = `-- name: GetAllMetrics :many
SELECT m.id,
       m.type,
       c.delta,
       g.value
FROM mtr_metrics AS m
         LEFT JOIN counter_metrics AS c ON m.id = c.metric_id
         LEFT JOIN gauge_metrics AS g ON m.id = g.metric_id
`

type GetAllMetricsRow struct {
	ID    domain.MetricName `db:"id" json:"id" validate:"required"`
	MType domain.MetricType `db:"type" json:"type" validate:"required,oneof=counter gauge"`
	Delta *int64            `db:"delta" json:"delta"`
	Value *float64          `db:"value" json:"value"`
}

func (q *Queries) GetAllMetrics(ctx context.Context) ([]GetAllMetricsRow, error) {
	rows, err := q.db.Query(ctx, GetAllMetrics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllMetricsRow
	for rows.Next() {
		var i GetAllMetricsRow
		if err := rows.Scan(
			&i.ID,
			&i.MType,
			&i.Delta,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetManyMetrics = `-- name: GetManyMetrics :many
SELECT m.id,
       m.type,
       c.delta,
       g.value
FROM mtr_metrics AS m
         LEFT JOIN counter_metrics AS c ON m.id = c.metric_id
         LEFT JOIN gauge_metrics AS g ON m.id = g.metric_id
WHERE m.id = ANY($1::text[])
`

type GetManyMetricsRow struct {
	ID    domain.MetricName `db:"id" json:"id" validate:"required"`
	MType domain.MetricType `db:"type" json:"type" validate:"required,oneof=counter gauge"`
	Delta *int64            `db:"delta" json:"delta"`
	Value *float64          `db:"value" json:"value"`
}

func (q *Queries) GetManyMetrics(ctx context.Context, dollar_1 []string) ([]GetManyMetricsRow, error) {
	rows, err := q.db.Query(ctx, GetManyMetrics, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetManyMetricsRow
	for rows.Next() {
		var i GetManyMetricsRow
		if err := rows.Scan(
			&i.ID,
			&i.MType,
			&i.Delta,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUnifiedMetric = `-- name: GetUnifiedMetric :one
SELECT m.id,
       m.type,
       c.delta,
       g.value
FROM mtr_metrics AS m
         LEFT JOIN counter_metrics AS c ON m.id = c.metric_id
         LEFT JOIN gauge_metrics AS g ON m.id = g.metric_id
WHERE m.id = $1
`

type GetUnifiedMetricRow struct {
	ID    domain.MetricName `db:"id" json:"id" validate:"required"`
	MType domain.MetricType `db:"type" json:"type" validate:"required,oneof=counter gauge"`
	Delta *int64            `db:"delta" json:"delta"`
	Value *float64          `db:"value" json:"value"`
}

func (q *Queries) GetUnifiedMetric(ctx context.Context, id domain.MetricName) (GetUnifiedMetricRow, error) {
	row := q.db.QueryRow(ctx, GetUnifiedMetric, id)
	var i GetUnifiedMetricRow
	err := row.Scan(
		&i.ID,
		&i.MType,
		&i.Delta,
		&i.Value,
	)
	return i, err
}

const InsertCounterMetric = `-- name: InsertCounterMetric :exec
INSERT INTO counter_metrics (metric_id, delta)
VALUES ($1, $2)
ON CONFLICT (metric_id) DO NOTHING
`

type InsertCounterMetricParams struct {
	MetricID domain.MetricName `db:"metric_id" json:"-"`
	Delta    *int64            `db:"delta" json:"delta"`
}

func (q *Queries) InsertCounterMetric(ctx context.Context, arg InsertCounterMetricParams) error {
	_, err := q.db.Exec(ctx, InsertCounterMetric, arg.MetricID, arg.Delta)
	return err
}

const InsertGaugeMetric = `-- name: InsertGaugeMetric :exec
INSERT INTO gauge_metrics (metric_id, value)
VALUES ($1, $2)
ON CONFLICT (metric_id) DO NOTHING
`

type InsertGaugeMetricParams struct {
	MetricID domain.MetricName `db:"metric_id" json:"-"`
	Value    *float64          `db:"value" json:"value"`
}

func (q *Queries) InsertGaugeMetric(ctx context.Context, arg InsertGaugeMetricParams) error {
	_, err := q.db.Exec(ctx, InsertGaugeMetric, arg.MetricID, arg.Value)
	return err
}

const InsertMtrMetric = `-- name: InsertMtrMetric :exec
INSERT INTO mtr_metrics (id, type)
VALUES ($1, $2)
ON CONFLICT (id, type) DO NOTHING
`

type InsertMtrMetricParams struct {
	ID    domain.MetricName `db:"id" json:"id" validate:"required"`
	MType domain.MetricType `db:"type" json:"type" validate:"required,oneof=counter gauge"`
}

func (q *Queries) InsertMtrMetric(ctx context.Context, arg InsertMtrMetricParams) error {
	_, err := q.db.Exec(ctx, InsertMtrMetric, arg.ID, arg.MType)
	return err
}

const UpdateCounterMetric = `-- name: UpdateCounterMetric :exec
UPDATE counter_metrics
SET delta = $2
WHERE metric_id = $1
`

type UpdateCounterMetricParams struct {
	MetricID domain.MetricName `db:"metric_id" json:"-"`
	Delta    *int64            `db:"delta" json:"delta"`
}

func (q *Queries) UpdateCounterMetric(ctx context.Context, arg UpdateCounterMetricParams) error {
	_, err := q.db.Exec(ctx, UpdateCounterMetric, arg.MetricID, arg.Delta)
	return err
}

const UpdateGaugeMetric = `-- name: UpdateGaugeMetric :exec
UPDATE gauge_metrics
SET value = $2
WHERE metric_id = $1
`

type UpdateGaugeMetricParams struct {
	MetricID domain.MetricName `db:"metric_id" json:"-"`
	Value    *float64          `db:"value" json:"value"`
}

func (q *Queries) UpdateGaugeMetric(ctx context.Context, arg UpdateGaugeMetricParams) error {
	_, err := q.db.Exec(ctx, UpdateGaugeMetric, arg.MetricID, arg.Value)
	return err
}

const UpsertCounterMetric = `-- name: UpsertCounterMetric :exec
INSERT INTO counter_metrics (metric_id, delta)
VALUES ($1, $2)
ON CONFLICT (metric_id) DO UPDATE
    SET delta = EXCLUDED.delta
`

type UpsertCounterMetricParams struct {
	MetricID domain.MetricName `db:"metric_id" json:"-"`
	Delta    *int64            `db:"delta" json:"delta"`
}

// Insert into counter_metrics or update if conflict on (metric_id)
func (q *Queries) UpsertCounterMetric(ctx context.Context, arg UpsertCounterMetricParams) error {
	_, err := q.db.Exec(ctx, UpsertCounterMetric, arg.MetricID, arg.Delta)
	return err
}

const UpsertGaugeMetric = `-- name: UpsertGaugeMetric :exec
INSERT INTO gauge_metrics (metric_id, value)
VALUES ($1, $2)
ON CONFLICT (metric_id) DO UPDATE
    SET value = EXCLUDED.value
`

type UpsertGaugeMetricParams struct {
	MetricID domain.MetricName `db:"metric_id" json:"-"`
	Value    *float64          `db:"value" json:"value"`
}

// Insert into gauge_metrics or update if conflict on (metric_id)
func (q *Queries) UpsertGaugeMetric(ctx context.Context, arg UpsertGaugeMetricParams) error {
	_, err := q.db.Exec(ctx, UpsertGaugeMetric, arg.MetricID, arg.Value)
	return err
}

const UpsertMtrMetric = `-- name: UpsertMtrMetric :exec
INSERT INTO mtr_metrics (id, type)
VALUES ($1, $2)
ON CONFLICT (id, type) DO UPDATE
    SET id = EXCLUDED.id, type = EXCLUDED.type
`

type UpsertMtrMetricParams struct {
	ID    domain.MetricName `db:"id" json:"id" validate:"required"`
	MType domain.MetricType `db:"type" json:"type" validate:"required,oneof=counter gauge"`
}

// Insert into mtr_metrics or update if conflict on (id, type)
func (q *Queries) UpsertMtrMetric(ctx context.Context, arg UpsertMtrMetricParams) error {
	_, err := q.db.Exec(ctx, UpsertMtrMetric, arg.ID, arg.MType)
	return err
}
